일부 데이터베이스는 RAM을 기본 스토리지 계층으로 취급
 > 메모리에 저장된 데이터가 클러스터 간에 복제되더라도, 정전으로 인해 여러 노드의 다운이 발생하면 데이터가 손실될 수 있다.
 > 베터리 백업을 사용해 정전 시 모든 데이터를 자동으로 디스크에 덤프 할 수 있다.

데이터를 지리적으로 분산함으로써 얻을 수 있는 내구성 및 가용성과, 스토리지를 소비자 또는 기록자와 가까운 좁은 지역에 보관함으로써 얻을 수 있는 성능 및 비용상의 이점 사이에서 항상 균형을 유지해야 한다.


#직렬화
 > 데이터를 평탄화하고 표준 포맷으로 패킹하는 프로세스, 판독기가 디코딩할 수 있다. 직렬화 형식은 데이터 교환의 표준을 제공한다.
데이터를 행 기반 방식으로 XML, JSON 또는 CSV파일로 인코딩해 다른 사용자에게 전달하면 표준 라이브러리를 사용해 데이터를 디코딩할 수 있다.
직렬화 알고리즘에는 유형(type)을 취급하는 로직이 있으며, 데이터 구조에 규칙을 부과하고 프로그래밍 언어와 CPU간의 교환을 허용한다.
데이터 엔지니어는 일반적인직렬화 관행과 형식, 특히 현재 가장 인기 있는 형식(예:아파치 파케이), 하이브리드 직렬화(예:아파치 후디) 및 인메모리 직렬화(예:아파치 애로)에 익숙해질 것을 권장한다.

#압축
 > 압축을 통해 디스크 공간을 줄일 수 있고, 디스크당 실제 검색속도가 향상되며, 네트워크 성능이 향상된다.
 단, 데이터 압축 및 해제시 시간과 자원이 추가로 소모된다.


 6.2 데이터 스토리지 시스템
#분산형 시스템에서 흔히 볼 수 있는 두 가지 일관성 패턴인 최종일관성 vs 강력한 일관성

BASE - 기본적으로 가용성을 보장하는(basically available), 소프트한 상태의(soft-state),최종 일관성(eventual consistency) <> ACID
 1. 기본적으로 가용성을 보장
  > 일관성을 보장하지는 않지만, 데이터베이스 읽기 및 쓰기는 최선의 노력을 기반으로 이루어지므로 대부분의 경우 일관된 데이터를 사용할 수 있다.
 2. 소프트한 상태
  > 트랜잭션의 상태가 불분명하며 트랜잭션이 커밋되었는지 커밋되지 않았는지 불확실하다.
 3. 최종 일관성
  > 어느 시점에서 데이터를 읽으면 일관된 값을 반환한다.

강력한 일관성
 > 모든 노드에 대한 쓰기가 합의에 따라 분산되고, 데이터베이스에 대한 모든 읽기가 일관된 값을 반환하도록 보장한다.


파일 스토리지
 파일의 특성
  > 파일은 길이가 유한한 바이트 스트림이다.
  > 호스트 스토리시 시스템의 한계까지 파일에 바이트를 추가할 수 있다.
  > 파일의 모든 위치에서 조회하거나 갱신할 수 있다.

 디스크가 연결된 서버에서 파일을 처리해야 할 때 처리 단계 사이의 중간 스토리지로 객체 스토리지를 사용하자.
 일회성 수집 단계나 파이프라인 개발의 탐색 단계를 위해 수동저수준 파일 처리를 예약해 두자.


객체 저장소
  > 객체 저장소는 각 작업에서 대량의 데이터를 갱신하는 낮은 속도의 갱신 작업에 적합하다.
   <> 매초마다 많은 소규모 갱신이 이루어지는 트랜잭션 워크로드에 적합하지 않으며, 이러한 사용 사례는 트랜잭션 데이터베이스 또는 블록 스토리지 시스템에서 훨씬 잘 처리된다.
  > 객체 저장소는 키-값 쌍 저장소이다. 파일 저장소와 달리 객체 저장소는 디렉터리 트리를 사용해 객체를 검색하지 않는다.
  > 클라우드 콘솔 인터페이스에서는 사용자가 '디렉터리' 내의 객체를 볼 수 있으며 클라우드 명령줄 도구는 객체 저장소 디렉터리 내의 ls와 같은 유닉스 스타일의 명령을 지원하는 경우가 많으나 백그라운드에서 객체 시스템은 디렉터리 트리를 탐색해 객체에 도달하지 않는다.
  > aws ls S3://oreilly-data-engineering=book/projectdata/11/을 실행하려면 객체 저장소가 키 접두사 project-data/11/에서 키를 필터링해야 한다. 버킷에 수백만개의 객체가 포함된 경우에는 '하위 디렉터리'에 몇 개의 객체만 저장하더라도 이 작업에 시간이 꽤 걸릴 수 있다.

   > 객체를 갱신하려면 동일한 키로 새 객체를 작성한다. 데이터 엔지니어가 데이터 프로세스에서 갱신을 활용 할 때는 사용 중인 객체 저장소의 일관성 모델을 알고 있어야 한다.
   > 객체 저장소에 강력한 일관성을 부여 하기 위해 사용 되는 표준 방법 중 한가지 접근 방식은 강력한 일관서잉 있는 데이터베이스(예:PostreSQL)를 추가하는 것
    1. 객체를 쓴다.
    2. 객체 버전에 대해 반환된 메타데이터를 강력한 일관성의 데이터베이스에 쓴다.

    객체를 읽을 때 리더는 다음 단계를 수행한다.
     1. 강력한 일관성의 데이터베이스에서 최신 객체 메타데이터를 가져온다.
     2. 객체 키를 사용해 객체 메타데이터를 쿼리한다. 일관성 있는 데이터베이스에서 가져온 메타데이터와 일치하는 객체 데이터를 읽어온다.
     3. 객체 메타데이터가 일치하지 않으면 객체의 최신 버전이 반환될 때까지 2를 반복한다.

    객체 저장소의 기존 키로 객체를 다시 쓴느 경우, 기본적으로 새로운 객체를 쓰고 기존 키에서 객체에 대한 참조를 설정하고 오래된 객체 참조를 삭제한다.
    
    객체의 과거 버전은 일반적으로 현재 버전과 동일한 관련 스토리지 비용이 발생한다.
    엔지니어는 스토리지 수명 주기 정책을 도입할 수도 있다. 수명 주기 정책을 사용하면 특정 조건이 충족될 떄(예를 들어 객체 버전이 특정 기간에 도달하거나 많은 최신 버전이 존재 할떄) 오래된 객체 버전을 자동으로 삭제 할 수 있다.


캐시 및 메모리 기반 스토리지 시스템
 > 데이터 엔지니어가 초고속 검색 지연 시간으로 데이터를 제공해야 할 때 유용하다.

하둡 분산 파일 시스템
 > 하둡은 동일한 노드에서 컴퓨팅과 스토리지를 결합하지만, 객체 저장소는 일반적으로 내부 프로세싱을 제한적으로 지원한다.
 > 하둡은 단순한 스토리지 시스템이 아니며, 컴퓨팅 리소스를 스토리지 노드와 결합해 제자리 데이터 처리를 지원한다.

스트리밍 스토리지
 > 메시지 큐의 경우, 저장된 데이터는 일시적이며 일정 기간이 지나면 사라질 것으로 예상되나, 아파치 카프카 같은 분산되고 확장 가능한 스트리밍 프레임워크는 매우 오랜 기간 데이터를 유지할 수 있도록 되었다.
  카프카는 자주 접근하지 않는 오래된 메시지를 객체 스토리지에 푸시해 무기한 데이터 보존을 지원한다.

 > 리플레이를 사용하면 스트리밍 시스템에 저장된 과거 데이터의 범위를 반환할 수 있다. 스트리밍 스토리지 시스템의 표준 데이터 검색 메커니즘이다.


인덱스, 파티셔닝 및 클러스터링

 # 행에서 열로 진화
  > 데이터를 열별로 배열하면 서로 유사한 값이 모이므로 압축 오버헤드를 최소화하면서 높은 압축률을 얻을 수 있다.
  > 다수의 개별 행을 비동기적으로 검색하려고 할 떄 성능이 떨어진다.
  > 복잡한 데이터 변호나, 집계, 통계, 계산 또는 대규모 데이터셋의 복잡한 조건 평가 등 대량의 데이터를 스캔해야 할 떄는 매우 우수한 성능을 발휘한다.

 # 인덱스부터 파티션 및 클러스터링까지
  > 분석 및 데이터 과학 사용 사례에서는 보통 시간 범위로 검색하므로 날짜 및 시간 기반 파티셔닝이 매우 일반적이다.
